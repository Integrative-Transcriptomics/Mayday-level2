package mayday.motifsearch.sequenceLogo;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.Arrays;

import mayday.core.structures.linalg.matrix.DoubleMatrix;

import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;



/**
 * Generates (DNA) SequenceLogos from matrices. The Matrix-field m(i,j) should
 * contain the value of nucleotide i at position j.
 * 
 * @author Sebastian Nerz, modified by Fredrik Weber
 * 
 */
public abstract class SequenceLogo {
    //private static Logger log = LoggerFactory.getLogger(SequenceLogo.class);

    /**
     * Default pixel-width of the resulting sequence-logos.
     */
    private static int WIDTH = 50;
    /**
     * Default height of the resulting sequence-logos.
     */
    private static int HEIGHT = 50;
    /**
     * Coefficient to be used in the logo generation. Enlarge this value if the
     * dataset used to construct the motif was very small.
     */
    private static double eCoeff = 0;
    /**
     * Colors of each nucleotide.
     */
    private static Color[] colors = new Color[] { Color.RED, Color.BLUE,
	Color.GREEN, Color.YELLOW };
    /**
     * List of nucleotides. It is important that the nucleotide corresponding to
     * row i of an input matrix is nucleo[i]
     */
    private static char[] nucleo = CONSTANTS.ALPHABET;
    /**
     * As log_2(x) = log10(x) / log10(2) we need log2.
     */
    private final static double log2 = CONSTANTS.LOG2;






    /**
     * Generates a sequence logo of (pixel-)size width*height from the given
     * motif-matrix on a Graphics2D object. The number of rows in the given matrix must match the
     * number of nucleotides defined in {@link #nucleo} and each column of the
     * matrix is considered to be one position of the motif. The number of
     * columns must be less then or equal the requested width, and neither width
     * nor height may be zero or negative.
     * 
     * @param g2d
     *            Graphics2D object to draw on, color and background must be preset
     * @param motif
     *            Motif-matrix as e.g. generated by MCMC_Motif
     * @param width
     *            Width of the generated sequence logo
     * @param height
     *            Height of the generated sequence logo
     * @return Generated sequence logo over the given matrix.
     */
    public static final void paintGraphics(Graphics2D g2d, DoubleMatrix motif, int width,
	    int height,  boolean areCoorinatesPainted, boolean isBackgroundWhite) {

	/* anti aliasing activation and other rendering hints */
	RenderingHints newRenderingHints = g2d.getRenderingHints();
	newRenderingHints.put(RenderingHints.KEY_ANTIALIASING,
		RenderingHints.VALUE_ANTIALIAS_ON);
	g2d.setRenderingHints(newRenderingHints);
	newRenderingHints.put(RenderingHints.KEY_ALPHA_INTERPOLATION,
		RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
	newRenderingHints.put(RenderingHints.KEY_RENDERING,
		RenderingHints.VALUE_RENDER_QUALITY);
	newRenderingHints.put(RenderingHints.KEY_COLOR_RENDERING,
		RenderingHints.VALUE_COLOR_RENDER_QUALITY);
	g2d.setRenderingHints(newRenderingHints);

	if (width <= 0 || height <= 0) {
	    String info = "Width (found " + width + ") and Height(found "
	    + height + ") must be over zero.";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	if (motif == null) {
	    String info = "motif must be defined";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	if (motif.nrow() != nucleo.length) {
	    String info = "number of rows in the motif-matrix (" + motif.nrow()
	    + ") must match number of nucleotides defined ("
	    + nucleo.length + ")";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	if (motif.ncol() > width) {
	    String info = "Width ("
		+ width
		+ ") must be higher or at least equal to the number of columns in the motif-matrix("
		+ motif.ncol() + ")";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}

	g2d.fillRect(0, 0, width, height);
	g2d.setFont(new Font("Sans-Serif", Font.PLAIN, 12));

	int heightForXCoordiante = (areCoorinatesPainted?(int)(0.2* height):0);
	int widthForYCoordiantes = (areCoorinatesPainted?(int)(0.1*width):0);
	int widthPerPos = (width -widthForYCoordiantes) / motif.ncol();

	double[] h = new double[motif.ncol()];
	double[] r = new double[motif.ncol()];

	sortableNucleo[][] sN = new sortableNucleo[motif.ncol()][nucleo.length];
	double maxR = 0;
	// for each position
	for (int pos = 0; pos < motif.ncol(); ++pos) {
	    sortableNucleo[] mySN = new sortableNucleo[nucleo.length];
	    /** total height at the position */
	    double hl = 0;
	    // for each nucleotide: "nucleotide-height" = motif-value of this
	    // nucleotide at the position * log_2(val)
	    for (int i = 0; i < motif.nrow(); ++i) {
		double val = motif.getValue(i, pos);
		if (val > 0) {
		    hl += val * Math.log10(val) / log2;
		    //					System.out.println(hl);
		}
		mySN[i] = new sortableNucleo(val, i);
	    }
	    // Sort the nucleotides according to their value
	    // ("higher valued nucleotides" are stacked at the top)
	    Arrays.sort(mySN);
	    // and save the list of nucleotide/height-pairs for this position
	    sN[pos] = mySN;
	    // total height at this position
	    h[pos] = hl;
	    // r-value at this position
	    r[pos] = 2 - (hl + eCoeff);
	    // r-value new maxR-value?
	    if (r[pos] > maxR) {
		maxR = r[pos];
	    }
	}

	int stapleHeigth = height - heightForXCoordiante;

	if (areCoorinatesPainted) {
	    g2d.setColor((isBackgroundWhite?Color.BLACK:Color.WHITE));

	    //draw x-coorinate
	    g2d.drawLine(widthForYCoordiantes-1,
		    stapleHeigth + 2, 
		    width-2,
		    stapleHeigth + 2);

	    //draw y-coorinate
	    g2d.drawLine(widthForYCoordiantes-2,
		    0 + 2, 
		    widthForYCoordiantes - 2, 
		    stapleHeigth + 2 + 1);



	    g2d.drawLine(widthForYCoordiantes-4,
		    stapleHeigth/2, 
		    widthForYCoordiantes - 2, 
		    stapleHeigth/2);
	    g2d.drawString("1", widthForYCoordiantes-4 - g2d.getFontMetrics().stringWidth("1"), ((stapleHeigth/2) + (g2d.getFontMetrics().getHeight()/2)));

	    g2d.drawLine(widthForYCoordiantes-4,
		    1, 
		    widthForYCoordiantes-2, 
		    1);
	    g2d.drawString("2", widthForYCoordiantes-4 - g2d.getFontMetrics().stringWidth("2"), (1 + (g2d.getFontMetrics().getHeight())));

	    g2d.drawLine(widthForYCoordiantes-4,
		    stapleHeigth, 
		    widthForYCoordiantes-2, 
		    stapleHeigth);
	    g2d.drawString("0", widthForYCoordiantes-4 - g2d.getFontMetrics().stringWidth("0"), (stapleHeigth + (g2d.getFontMetrics().getHeight())));


	    g2d.drawString("bits", 0, ((stapleHeigth/2) + (g2d.getFontMetrics().getHeight()/2)));



	    g2d.drawString("5'", widthForYCoordiantes - g2d.getFontMetrics().stringWidth("5'"), stapleHeigth + 2 + g2d.getFontMetrics().getHeight()*2);
	    g2d.drawString("3'", width -g2d.getFontMetrics().stringWidth("3'") -1, stapleHeigth + 2 + g2d.getFontMetrics().getHeight()*2);

	}
	// for each position: paint the nucleotides found
	for (int pos = 0; pos < motif.ncol(); ++pos) {
	    /**
	     * Sum of the nucleotide-heights in this position
	     */
	    int heightSoFar = 0;

	    if (areCoorinatesPainted) {
		g2d.setColor((isBackgroundWhite?Color.BLACK:Color.WHITE));
		//draw the position
		int drawXPosOfCoordiante = widthForYCoordiantes + widthPerPos * pos + (widthPerPos/2);
		g2d.drawLine(drawXPosOfCoordiante, stapleHeigth + 2, drawXPosOfCoordiante, stapleHeigth + 2 + 2);
		g2d.drawString(String.valueOf(pos+1), drawXPosOfCoordiante 
			- (g2d.getFontMetrics().stringWidth(String.valueOf(pos+1))/2)
			, stapleHeigth + 2 + 1
			+ g2d.getFontMetrics().getHeight()
		);
	    }

	    // for each nucleotide at this position
	    for (int i = 0; i < sN[pos].length; ++i) {
		if (sN[pos][i].val <= 0) {
		    continue;
		}
		// Create a "character-image" of the needed height and width

		// height: "nucleotide-value" * r-value / max-rValue ->
		// normalized to max=1
		// * image-height -> normalized to
		// "max-height = image-height, all other positions smaller"
		int heights = (int) (sN[pos][i].val * r[pos] / maxR * stapleHeigth);
		FontRenderContext frc = g2d.getFontRenderContext();
		// Char-representation of the nucleotide
		String s = nucleo[sN[pos][i].nr] + "";
		// "Image representation" of the nucleotide
		GlyphVector gv = g2d.getFont().createGlyphVector(frc, s);
		Shape outline = gv.getOutline();
		Rectangle2D oBounds = outline.getBounds2D();
		AffineTransform at = new AffineTransform();
		// move it to the needed position
		at.setToTranslation(widthForYCoordiantes + widthPerPos * pos, stapleHeigth - heightSoFar
			- heights);
		// and scale it
		at.scale(widthPerPos / oBounds.getWidth(), heights
			/ oBounds.getHeight() );
		at.translate(-oBounds.getMinX(), -oBounds.getMinY());
		outline = at.createTransformedShape(outline);
		// and paint it to the image
		g2d.setPaint(colors[sN[pos][i].nr]);
		g2d.fill(outline);
		g2d.draw(outline);

		// add next char will start below this one
		heightSoFar += heights;
	    }
	}

    }
    /**
     * Generates a sequence logo of (pixel-)size width*height from the given
     * motif-matrix. The number of rows in the given matrix must match the
     * number of nucleotides defined in {@link #nucleo} and each column of the
     * matrix is considered to be one position of the motif. The number of
     * columns must be less then or equal the requested width, and neither width
     * nor height may be zero or negative.
     * 
     * @param motif
     *            Motif-matrix as e.g. generated by MCMC_Motif
     * @param width
     *            Width of the generated sequence logo
     * @param height
     *            Height of the generated sequence logo
     * @return Generated sequence logo over the given matrix.
     */
    public static BufferedImage generateImage(DoubleMatrix motif, int width,
	    int height) {
	if (width <= 0 || height <= 0) {
	    String info = "Width (found " + width + ") and Height(found "
	    + height + ") must be over zero.";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	if (motif == null) {
	    String info = "motif must be defined";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	if (motif.nrow() != nucleo.length) {
	    String info = "number of rows in the motif-matrix (" + motif.nrow()
	    + ") must match number of nucleotides defined ("
	    + nucleo.length + ")";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	if (motif.ncol() > width) {
	    String info = "Width ("
		+ width
		+ ") must be higher or at least equal to the number of columns in the motif-matrix("
		+ motif.ncol() + ")";
	    //log.info("generateImage: {}", info);
	    throw new IllegalArgumentException(info);
	}
	BufferedImage bi = new BufferedImage(width, height,
		BufferedImage.TYPE_INT_RGB);

	Graphics2D g2d = bi.createGraphics();

	// blank image
	g2d.setColor(Color.WHITE);
	g2d.setBackground(Color.WHITE);
	g2d.fillRect(0, 0, bi.getWidth(), bi.getHeight());
	g2d.setFont(new Font("Sans-Serif", Font.PLAIN, 12));

	int widthPerPos = width / motif.ncol();

	double[] h = new double[motif.ncol()];
	double[] r = new double[motif.ncol()];

	sortableNucleo[][] sN = new sortableNucleo[motif.ncol()][nucleo.length];
	double maxR = 0;

	// for each position
	for (int pos = 0; pos < motif.ncol(); ++pos) {
	    sortableNucleo[] mySN = new sortableNucleo[nucleo.length];
	    /** total height at the position */
	    double hl = 0;
	    // for each nucleotide: "nucleotide-height" = motif-value of this
	    // nucleotide at the position * log_2(val)
	    for (int i = 0; i < motif.nrow(); ++i) {
		double val = motif.getValue(i, pos);
		if (val > 0) {
		    hl += val * Math.log10(val) / log2;
		}
		mySN[i] = new sortableNucleo(val, i);
	    }
	    // Sort the nucleotides according to their value
	    // ("higher valued nucleotides" are stacked at the top)
	    Arrays.sort(mySN);
	    // and save the list of nucleotide/height-pairs for this position
	    sN[pos] = mySN;
	    // total height at this position
	    h[pos] = hl;
	    // r-value at this position
	    r[pos] = 2 - (hl + eCoeff);
	    // r-value new maxR-value?
	    if (r[pos] > maxR) {
		maxR = r[pos];
	    }
	}

	// for each position: paint the nucleotides found
	for (int pos = 0; pos < motif.ncol(); ++pos) {
	    /**
	     * Sum of the nucleotide-heights in this position
	     */
	    int heightSoFar = 0;
	    // for each nucleotide at this position
	    for (int i = 0; i < sN[pos].length; ++i) {
		if (sN[pos][i].val <= 0) {
		    continue;
		}
		// Create a "character-image" of the needed height and width

		// height: "nucleotide-value" * r-value / max-rValue ->
		// normalized to max=1
		// * image-height -> normalized to
		// "max-height = image-height, all other positions smaller"
		int heights = (int) (sN[pos][i].val * r[pos] / maxR * height);
		FontRenderContext frc = g2d.getFontRenderContext();
		// Char-representation of the nucleotide
		String s = nucleo[sN[pos][i].nr] + "";
		// "Image representation" of the nucleotide
		GlyphVector gv = g2d.getFont().createGlyphVector(frc, s);
		Shape outline = gv.getOutline();
		Rectangle2D oBounds = outline.getBounds2D();
		AffineTransform at = new AffineTransform();
		// move it to the needed position
		at.setToTranslation(widthPerPos * pos, height - heightSoFar
			- heights);
		// and scale it
		at.scale(widthPerPos / oBounds.getWidth(), heights
			/ oBounds.getHeight());
		at.translate(-oBounds.getMinX(), -oBounds.getMinY());
		outline = at.createTransformedShape(outline);
		// and paint it to the image
		g2d.setPaint(colors[sN[pos][i].nr]);
		g2d.fill(outline);
		g2d.draw(outline);

		// add next char will start below this one
		heightSoFar += heights;
	    }
	}

	g2d.dispose();
	return bi;
    }

    /**
     * Generates a sequence-logo out of the given motif-matrix with default
     * width and height. If the number of positions in the motif is higher then
     * the default width, the number of positions is used.
     * 
     * @param motif
     *            Matrix to generate the sequence-logo from.
     * @return Generated sequence logo.
     * @see #generateImage(DoubleMatrix, int, int)
     */
    public static BufferedImage generateImage(DoubleMatrix motif) {
	if (motif != null && motif.ncol() > WIDTH) {
	    return generateImage(motif, motif.ncol(), HEIGHT);
	}
	return generateImage(motif, WIDTH, HEIGHT);
    }
}

/**
 * SortableNucleos are used to sort "nucleotides" according to their
 * (sequence-logo) value.
 * 
 * @author Sebastian Nerz
 * 
 */
class sortableNucleo implements Comparable<sortableNucleo> {
    double val;
    int nr;

    sortableNucleo(double val, int nr) {
	this.val = val;
	this.nr = nr;
    }

    @Override
    public String toString() {
	return new ToStringBuilder(this).append("Nr", nr).append("Value", val)
	.toString();
    }

    public int compareTo(sortableNucleo o) {
	return new CompareToBuilder().append(val, o.val).append(nr, o.nr)
	.toComparison();
    }

    @Override
    public boolean equals(Object o) {
	if (o instanceof sortableNucleo) {
	    return EqualsBuilder.reflectionEquals(this, o);
	}
	return false;
    }

    public int hashcode() {
	return HashCodeBuilder.reflectionHashCode(this);
    }
}
